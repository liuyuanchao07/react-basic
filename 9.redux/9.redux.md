redux/react-redux 两者配合完成组件间通信的技术
不管任何类型的组件都可以基于这种方案实现组件通信

在创建组件store容器中 存储两部分的内容
  + 公共状态：各组件需要共享的信息
  + 事件池：存放一些方法「让组件可以更新的方法」
  特点：公共状态一旦发生改变会默认立即通知事件池的方法执行
       这些方法执行主要目的就是让指定的组件更新 而组件一更新 就可以获取最新的公共状态进行渲染

修改公共容器中的状态 不能直接修改
  + 要基于dispatch派发 通知reducer执行
  + 在reducer中实现状态的更新

1.创建全局的公共容器 用来存储各组件需要共享的信息
const store = createStore([reducer]);

2.在组件内部获取公用状态 然后渲染
  store.getState() => 返回结果是一个对象 {supNum, oppNum}

3.把让组件可以更新的方法放到公共容器的事件池中
  后期公共状态改了 事件池中的方法会按顺序依次执行 也就是让对应的组件也更新 组件只要更新就可以从store中获取最新的状态渲染
  store.subscribe(函数)

4.创建容器的时候需要传递reducer 相当于一个管理员
  let init = {...} 初始状态
  const reducer = function reducer(state = init, action) {
    // state容器中的状态
    // action是派发的行为对象（必须具备type属性）
    switch(action.type {
      // 根据传递的type不同 修改不同状态的信息
    })
    return state // 返回的信息会替换store容器中的状态
  }

5.基于派发任务通知reducer执行修改状态
  store.dispatch({
    type: xxx,
    ...
  })


redux工程化开发：在真正的项目中 我们一定会把状态和reducer的管理 按照模块化进行划分
1.按照模块 把reducer进行单独管理 每个模块有自己的reducer 最后还要把所有的reducer合并成一个 赋值给创建的store
2.派发行为标识的统一管理
3.派发的行为对象按照模块统一管理
